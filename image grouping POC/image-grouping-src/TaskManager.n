using Nemerle.Collections;
using System;

using SCG = System.Collections.Generic;

public class TaskManager
{
	private persistData : bool;

	private items        : Hashtable[string, TaskItem];
	private taskMappings : list[list[TaskMapping]];

	private mutable toCompute : Set[string];
	private mutable loaded    : Set[string];

	public this(tasks : list[ITask], persistData : bool)
	{
		this.persistData = persistData;

		mutable taskMappings = [];
		mutable items        = [];
		foreach (task in tasks)
		{
			def mappings = task.MapItems(items);
			foreach (mapping in mappings)
				items = mapping.Outputs.Append(items);
			taskMappings ::= mappings;
		}

		this.taskMappings = taskMappings.Reverse();

		this.items = Hashtable();
		foreach (item in items)
			this.items.Add(item.Name, item);

		this.toCompute = Set();
		foreach (item in items)
		{
			unless (item.Data.HasCache())
				this.toCompute = this.toCompute.Add(item.Name);
		}

		this.loaded = Set();
	}

	public Items : SCG.IEnumerable[string]
	{
		get { items.Keys }
	}

	public DiscardItemData(name : string) : void
	{
		when (!items.Contains(name))
			throw ArgumentException("name");
		toCompute = toCompute.Replace(name);
	}

	public Compute() : void
	{
		def ToCompute(item) { toCompute.Contains(item.Name) }
		foreach (layer in taskMappings)
		{
			foreach (mapping in layer)
			{
				def i = mapping.Inputs;
				def o = mapping.Outputs;
				when (i.Exists(ToCompute) || o.Exists(ToCompute))
				{
					foreach (item in i)
					{
						when (!loaded.Contains(item.Name) && item.Data.HasCache())
						{
							loaded = loaded.Add(item.Name);
							item.Data.Load();
						}
					}
					Console.WriteLine($"..$i -> ..$o");
					mapping.Compute();
					toCompute = toCompute.ReplaceList(o.Map(_.Name));
				}
			}
		}
		when (persistData)
		{
			foreach (name in toCompute)
				items[name].Data.Save();
		}
		toCompute = toCompute.Clear();
	}
}
