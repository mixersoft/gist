using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using Emgu.CV;
using Nemerle.Collections;
using Nemerle.Utility;
using PipelineMacro;
using System.Drawing;
using System.IO;
using System;

[ Record ]
class FindDominantColorTask : ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable mappings = [];
		foreach (item is ImageCollectionItem in items)
			mappings ::= TaskMapping(this, [ item ], [ DominantColorItem(item.Name) ]);
		mappings;
	}

	private Compute
		( [InItem]  images : ImageCollectionItem
		, [OutItem] result : DominantColorItem
		, dominantColorCount : int
		, colorSamplingStep  : int
		) : void
	{
		def imageCount = images.ImageIDs.Length;
		result.Colors = array(imageCount, dominantColorCount);
		for (mutable i = 0; i != imageCount; ++i)
		{
			Console.Write('*');
			def path   = images.MakePath(images.ImageIDs[i]);
			def colors = ToRgb(GetDominantColors(path, colorSamplingStep, dominantColorCount, 4));
			for (mutable j = 0; j != dominantColorCount; ++j)
				result.Colors[i, j] = colors[j];
		}
		Console.WriteLine();
	}

	private static GetDominantColors
		( imagePath         : string
		, colorSamplingStep : int
		, clusterCount      : int
		, totalClusters     : int
		) : array[float * float * float]
	{
		if (clusterCount == 0)
		{
			array(0);
		}
		else
		{
			def samples =
				using (image = LoadLabImage(imagePath))
					SampleImage(image, colorSamplingStep);

			def labels  = Matrix.[int](samples.Rows, 1);
			def centers = Matrix.[float](Math.Max(totalClusters, clusterCount), 3);

			_ = CvInvoke.cvKMeans2
				( samples      = samples.Ptr
				, clusterCount = centers.Rows
				, labels       = labels.Ptr
				, termcrit     = MCvTermCriteria(maxIteration = 10)
				, attempts     = 5
				, rng          = IntPtr.Zero
				, flags        = 0
				, centers      = centers.Ptr
				, compactness  = IntPtr.Zero
				);

			def result = array(clusterCount);
			for (mutable i = 0; i != clusterCount; ++i)
			{
				def l = centers[i, 0];
				def a = centers[i, 1];
				def b = centers[i, 2];
				result[i] = (l, a, b);
			}
			result;
		}
	}

	private static LoadLabImage(imagePath : string) : Image.[Bgr, float]
	{
		using (srcImage = Image.[Bgr, float](imagePath))
		{
			def dstImage = Image.[Bgr, float](srcImage.Size);
			// TODO: use Image.ConvertFrom
			CvInvoke.cvCvtColor
				( src  = srcImage.Ptr
				, dst  = dstImage.Ptr
				, code = COLOR_CONVERSION.CV_BGR2Lab
				);
			dstImage;
		}
	}

	private static SampleImage
		( image        : Image.[Bgr, float]
		, samplingStep : int
		) : Matrix.[float]
	{
		def sampledRows = image.Rows / samplingStep;
		def sampledCols = image.Cols / samplingStep;

		def samples = Matrix.[float](sampledRows * sampledCols, 3);
		for (mutable c = 0; c < sampledCols; ++c)
		for (mutable r = 0; r < sampledRows; ++r)
		{
			def samplesRow = r * sampledCols + c;
			def color = image[r * samplingStep, c * samplingStep];
			samples[samplesRow, 0] = color.Red   :> float;
			samples[samplesRow, 1] = color.Green :> float;
			samples[samplesRow, 2] = color.Blue  :> float;
		}
		samples;
	}

	private static ToRgb(data : array[float * float * float]) : array[Color]
	{
		def src = Image.[Bgr, float](1, data.Length);
		for (mutable i = 0; i != data.Length; ++i)
		{
			def (l, a, b) = data[i];
			src[i, 0] = Bgr
				( red   = l
				, green = a
				, blue  = b
				);
		}

		def dst = Image.[Bgr, float](1, src.Rows);
		CvInvoke.cvCvtColor(src.Ptr, dst.Ptr, COLOR_CONVERSION.CV_Lab2BGR);

		def colors = array(dst.Rows);
		for (mutable i = 0; i != dst.Rows; ++i)
		{
			def color = dst[i, 0];
			colors[i] = Color.FromArgb
				( red   = color.Red   :> int
				, green = color.Green :> int
				, blue  = color.Blue  :> int
				);
		}
		colors;
	}
}
