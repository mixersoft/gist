using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using Emgu.CV;
using NanoFlannNet;
using Nemerle.Collections;
using Nemerle.Utility;
using PipelineMacro;
using System.Drawing;
using System.IO;
using System.Math;
using System;

public enum DominantColorMethod
{
| KMeans
| MeanShift
}

[ Record ]
class FindDominantColorTask : ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable mappings = [];
		foreach (item is ImageCollectionItem in items)
			mappings ::= TaskMapping(this, [ item ], [ DominantColorItem(item.Name) ]);
		mappings;
	}

	private Compute
		( [InItem]  images : ImageCollectionItem
		, [OutItem] result : DominantColorItem
		, dominantColorMethod : DominantColorMethod
		, dominantColorCount  : int
		, colorSamplingStep   : int
		) : void
	{
		def totalClusters = 4;

		def imageCount = images.ImageIDs.Length;
		result.Colors = array(imageCount, dominantColorCount);
		for (mutable i = 0; i != imageCount; ++i)
		{
			Console.Write('*');
			using (image = LoadLabImage(images.MakePath(images.ImageIDs[i])))
			{
				def lab = 
					match (dominantColorMethod)
					{
					| KMeans => GetKMeansDominantColors
						( image
						, colorSamplingStep
						, dominantColorCount
						, totalClusters
						)
					| MeanShift => GetMeanShiftDominantColors
						( image
						)
					};
				def colors = ToRgb(lab);
				for (mutable j = 0; j != dominantColorCount; ++j)
					result.Colors[i, j] = colors[j];
			}
		}
		Console.WriteLine();
	}

	private static GetKMeansDominantColors
		( image             : Image[Lab, float]
		, colorSamplingStep : int
		, clusterCount      : int
		, totalClusters     : int
		) : array[float * float * float]
	{
		def SampleImage(image, step)
		{
			def sampledRows = image.Rows / step;
			def sampledCols = image.Cols / step;

			def samples = Matrix.[float](sampledRows * sampledCols, 3);
			for (mutable c = 0; c < sampledCols; ++c)
			for (mutable r = 0; r < sampledRows; ++r)
			{
				def samplesRow = r * sampledCols + c;
				def color = image[r * step, c * step];
				samples[samplesRow, 0] = color.X :> float;
				samples[samplesRow, 1] = color.Y :> float;
				samples[samplesRow, 2] = color.Z :> float;
			}
			samples;
		}

		using (samples = SampleImage(image, colorSamplingStep))
		{
			def labels  = Matrix.[int](samples.Rows, 1);
			def centers = Matrix.[float](Max(totalClusters, clusterCount), 3);

			_ = CvInvoke.cvKMeans2
				( samples      = samples.Ptr
				, clusterCount = centers.Rows
				, labels       = labels.Ptr
				, termcrit     = MCvTermCriteria(maxIteration = 10)
				, attempts     = 5
				, rng          = IntPtr.Zero
				, flags        = 0
				, centers      = centers.Ptr
				, compactness  = IntPtr.Zero
				);

			def result = array(clusterCount);
			for (mutable i = 0; i != clusterCount; ++i)
			{
				def l = centers[i, 0];
				def a = centers[i, 1];
				def b = centers[i, 2];
				result[i] = (l, a, b);
			}
			result;
		}
	}

	private static GetMeanShiftDominantColors(image : Image[Lab, float]) : array[float * float * float]
	{
		def iterationCount = 10;

		def d = 3; // dimensionality
		def h = 10.0; // window

		def VectorizeFeatures()
		{
			def w = image.Width;
			def h = image.Height;
			def vectors = array(d * w * h);
			mutable k = 0;
			for (mutable y = 0; y != h; ++y)
			for (mutable x = 0; x != w; ++x)
			{
				for (mutable j = 0; j != d; ++j)
				{
					vectors[k] = image[y, x].X; ++k;
					vectors[k] = image[y, x].Y; ++k;
					vectors[k] = image[y, x].Z; ++k;
				}
			}
			vectors;
		}

		def features = VectorizeFeatures();
		def n = features.Length;

		// g(x) = exp(-xᵀx/2)/(2π)^(-d/2)
		def normFactor = Pow(2.0 * PI, -0.5 * d);
		def σ   = h;
		def var = h * h;

		def modes = array(n, d);
		def mode  = array(d);
		System.Array.Copy(features, modes, features.Length);

		def Iterate(tree)
		{
			mutable targetsCount = 0l;

			for (mutable i = 0; i != n; ++i)
			{
				mutable total;
				for (mutable k = 0; k != d; ++k)
					mode[k] = 0.0;

				def target = array(d);
				for (mutable k = 0; k != d; ++k)
					target[k] = features[i * d + k];
				def indices = tree.RadiusSearch(target, σ * 6.0);
				targetsCount += indices.Length;
				foreach (index in indices)
				{
					def index = index * d;

					mutable w; // K(‖x_i - x_j‖² / var)
					for (mutable k = 0; k != d; ++k)
					{
						def δ = modes[i, k] - features[index + k];
						w += δ * δ;
					}
					w = normFactor * Exp(-0.5 * w * w / var);
					total += w;
					for (mutable k = 0; k != d; ++k)
						mode[k] += features[index + k] * w;
				}
				if (total == 0.0)
				{
					for (mutable k = 0; k != d; ++k)
						modes[i, k] = 0.0;
				}
				else
				{
					for (mutable k = 0; k != d; ++k)
						modes[i, k] = mode[k] / total;
				}
			}
		}

		using (tree = KdTree(d, features))
		{
			repeat (iterationCount)
				Iterate(tree);
		}

		//modes;

		array(0);
	}

	private static LoadLabImage(imagePath : string) : Image[Lab, float]
	{
		// We should be able to simply use the constructor, but there is a bug in EmguCV.
		// http://www.emgu.com/bugs/show_bug.cgi?id=81
		//
		// Image.[Lab, float](imagePath);

		using (img = Image.[Bgr, float](imagePath))
		using (img = img / 255.0)
		{
			def lab = Image.[Lab, float](img.Width, img.Height);
			CvInvoke.cvCvtColor
				( src  = img.Ptr
				, dst  = lab.Ptr
				, code = COLOR_CONVERSION.CV_BGR2Lab
				);
			lab;
		}
	}

	private static ToRgb(data : array[float * float * float]) : array[Color]
	{
		def GetRgbImg()
		{
			using (img = Image.[Lab, float](1, data.Length))
			{
				for (mutable i = 0; i != data.Length; ++i)
				{
					def (x, y, z) = data[i];
					img[i, 0] = Lab(x, y, z);
				}
				img.Convert.[Bgr, float]();
			}
		}

		using (img = GetRgbImg())
		{
			def colors = array(img.Rows);
			for (mutable i = 0; i != img.Rows; ++i)
			{
				def color = img[i, 0];
				colors[i] = Color.FromArgb
					( red   = (255.0f * color.Red)   :> int
					, green = (255.0f * color.Green) :> int
					, blue  = (255.0f * color.Blue)  :> int
					);
			}
			colors;
		}
	}
}
