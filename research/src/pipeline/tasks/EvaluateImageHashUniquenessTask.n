using Nemerle.Collections;
using PipelineMacro;
using System.Drawing;
using System.IO;

class EvaluateImageHashUniquenessTask : ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable images     = [];
		mutable thumbnails = [];
		foreach (item is ImageCollectionItem in items)
		{
			def name = Path.GetFileName(item.Path);
			match (Path.GetDirectoryName(item.Path))
			{
			| "images"     => images     ::= (name, item)
			| "thumbnails" => thumbnails ::= (name, item)
			| _            => ()
			}
		}
		mutable mappings = [];
		foreach ((name, image) in images)
		{
			def thumbnail = thumbnails.Find(x => x[0] == name).Value[1];
			def path = Path.Combine("eval",  $"$name hash uniqueness.html");
			def result = ImageHashUniquenessEvaluationItem(path);
			mappings ::= TaskMapping(this, [ image, thumbnail ], [ result ]);
		}
		mappings;
	}

	private Compute
		( [InItem]  thumbnails : ImageCollectionItem
		, [InItem]  images     : ImageCollectionItem
		, [OutItem] evaluation : ImageHashUniquenessEvaluationItem
		, hashMethod      : ImageHash.HashMethod
		, hashedImageSize : int
		, hashedImageBpp  : int
		) : void
	{
		def map = Hashtable();
		foreach (id in thumbnails.ImageIDs)
		{
			def hash =
				using (bmp = Bitmap(images.MakePath(id)))
					ImageHash.GetHashCode(bmp, hashMethod, hashedImageSize, hashedImageBpp);
			map[hash] = id :: map.GetValueOrDefault(hash);
		}
		evaluation.Conflicts = map.MapToArrayFiltered
			( isMatch = pair => pair.Value.Length > 1
			, convert = pair => pair.Value.ToArray()
			);
		evaluation.MakeImagePathFromID = thumbnails.MakePath;
	}
}
