using Nemerle.Collections;
using PipelineMacro;
using System.Collections.Generic;
using System;

public class EvaluateDuplicatesTask: ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable mappings = [];
		foreach ((name, auto, refs, json) in items.Join.[DuplicatesItem, DuplicatesRefItem, JsonItem]())
		{
			mappings ::= TaskMapping
				( this
				, [ auto, refs, json ]
				, [ DuplicatesEvaluationItem(name) ]
				);
		}
		mappings;
	}

	private Compute
		( [InItem]  auto  : DuplicatesItem
		, [InItem]  refs   : DuplicatesRefItem
		, [InItem]  json   : JsonItem
		, [OutItem] result : DuplicatesEvaluationItem
		) : void
	{
		def GetPhotosHash()
		{
			json.Photos.Fold(0, (photo, hash) => photo.ID.GetHashCode() ^ hash)
		}
		when (refs.Hash != GetPhotosHash())
			throw InconsistentItemsException("Reference generated from different images.");

		def GatherIndices()
		{
			mutable indices = Set();
			mutable i = 0;
			foreach (group in auto.ImageIDs)
			for (mutable j = 0; j != group.Length; ++j)
			{
				when (j != 0)
					indices = indices.Add(i);
				++i;
			}
			indices;
		}

		def refs = Set(refs.Indices);
		def auto = GatherIndices();

		def photos = json.Photos.Sort(_.DateTaken);
		def GetPhotoID(i) { photos[i].ID }

		result.FalsePositives = Set(auto.Subtract(refs).Map(GetPhotoID));
		result.FalseNegatives = Set(refs.Subtract(auto).Map(GetPhotoID));

		def fp = result.FalsePositives.Count;
		def fn = result.FalseNegatives.Count;

		result.Score = 1.0 - (fp + fn) / (photos.Length :> double);
	}
}
