using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using Emgu.CV;
using Nemerle.Collections;
using PipelineMacro;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System;

[ Record ]
class DetectFacesTask : ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable mappings = [];
		foreach (images is ImageCollectionItem in items)
			mappings ::= TaskMapping(this, [ images ], [ FacesItem(images.Name) ]);
		mappings;
	}

	// Image<Gray, byte> grayframe = nextFrame.Convert<Gray, byte>();
	// var faces =
	// 	grayframe.DetectHaarCascade(
	// 		haar, 1.4, 4,
	// 		HAAR_DETECTION_TYPE.DO_CANNY_PRUNING,
	// 		new Size(nextFrame.Width/8, nextFrame.Height/8)
	// 		)[0];
	// 
	// foreach (var face in faces)
	// {
	// 	nextFrame.Draw(face.rect, new Bgr(0,double.MaxValue,0), 3);
	// }
	// pictureBox1.Image = nextFrame.ToBitmap();

	private Compute
		( [InItem]  images : ImageCollectionItem
		, [OutItem] faces  : FacesItem
		) : void
	{
		mutable imageFaces = Hashtable();

		def haar = HaarCascade(@"data\assets\haarcascade_frontalface_default.xml");

		foreach (id in images.ImageIDs)
		{
			using (img = Image.[Gray, byte](images.MakePath(id)))
			{
				def rects = haar.Detect
					( image        = img
					, scaleFactor  = 1.1
					, minNeighbors = 3
					, flag         = HAAR_DETECTION_TYPE.DO_CANNY_PRUNING
					, minSize      = Size.Empty
					, maxSize      = Size.Empty
					);
				when (rects.Length > 0)
					imageFaces[id] = rects.Map(_.rect);
			}
		}

		faces.ImageFaces = imageFaces;
	}
}
