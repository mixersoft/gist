using Emgu.CV.Structure;
using Emgu.CV;
using Nemerle.Collections;
using PipelineMacro;
using System.Diagnostics;
using System.Drawing;
using System.IO;

class ComputeDiscreteHaarTask : ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable mappings = [];
		foreach (item is ImageCollectionItem in items)
			mappings ::= TaskMapping(this, [ item ], [ HaarItem(item.Name) ]);
		mappings;
	}

	private Compute
		( [InItem]  images : ImageCollectionItem
		, [OutItem] haar   : HaarItem
		) : void
	{
		_ = Directory.CreateDirectory(Path.GetDirectoryName(haar.Path));
		DirectoryEx.Recreate(haar.Path);

		haar.ImageIDs = images.ImageIDs;
		foreach (id in images.ImageIDs)
		{
			using (src = Image.[Bgr, byte](images.MakePath(id)))
			using (dst = Transform(src, 3))
				dst.Save(haar.MakePath(id));
		}
	}

	private Transform(img : Image.[Bgr, byte], iterations : int) : Image.[Bgr, byte]
	{
		def GetRgb(color)
		{
			( color.Red   :> int
			, color.Green :> int
			, color.Blue  :> int
			)
		}

		def HaarEncode(src, rect)
		{
			Trace.Assert(rect.Width  % 2 == 0);
			Trace.Assert(rect.Height % 2 == 0);

			def Encode(c1, c2)
			{
				def (sr1, sg1, sb1) = GetRgb(c1);
				def (sr2, sg2, sb2) = GetRgb(c2);

				mutable r2 = sr2 - sr1;
				mutable g2 = sg2 - sg1;
				mutable b2 = sb2 - sb1;

				when (r2 < -128) r2 += 256; when (r2 > 127) r2 -= 256;
				when (g2 < -128) g2 += 256; when (g2 > 127) g2 -= 256;
				when (b2 < -128) b2 += 256; when (b2 > 127) b2 -= 256;

				mutable r1 = (sr1 - 128 + r2 / 2);
				mutable g1 = (sg1 - 128 + g2 / 2);
				mutable b1 = (sb1 - 128 + b2 / 2);

				when (r1 < -128) r1 += 256; when (r1 >  127) r1 -= 256;
				when (g1 < -128) g1 += 256; when (g1 >  127) g1 -= 256;
				when (b1 < -128) b1 += 256; when (b1 >  127) b1 -= 256;

				r1 += 128; g1 += 128; b1 += 128;
				r2 += 128; g2 += 128; b2 += 128;

				( Bgr(r1, g1, b1)
				, Bgr(r2, g2, b2)
				)
			}

			def RunHorizontalPass(src) : Image.[Bgr, byte]
			{
				def dst = src.Copy();
				for (mutable y = rect.Y; y != rect.Height; ++y)
				for (mutable x = rect.X; x != rect.Width; x += 2)
				{
					def c1 = src[y, x];
					def c2 = src[y, x + 1];

					def (c1, c2) = Encode(c1, c2);

					dst[y, x / 2] = c1;
					dst[y, x / 2 + rect.Width / 2] = c2;
				}
				dst;
			}

			def RunVerticalPass(src) : Image.[Bgr, byte]
			{
				def dst = src.Copy();
				for (mutable y = rect.Y; y != rect.Height; y += 2)
				for (mutable x = rect.X; x != rect.Width; ++x)
				{
					def c1 = src[y, x];
					def c2 = src[y + 1, x];

					def (c1, c2) = Encode(c1, c2);

					dst[y / 2, x] = c1;
					dst[y / 2 + rect.Height / 2, x] = c2;
				}
				dst;
			}

			using (tmp = RunHorizontalPass(src))
				RunVerticalPass(tmp);
		}

		Trace.Assert(iterations > 0 && iterations < 32);

		def RoundDown(n, multiple) { n / multiple * multiple }
		mutable w = RoundDown(img.Width,  1 << iterations);
		mutable h = RoundDown(img.Height, 1 << iterations);

		mutable src = img;
		mutable dst;
		repeat (iterations)
		{
			dst = HaarEncode(src, Rectangle(0, 0, w, h));
			w /= 2; h /= 2;
			src.Dispose();
			src <-> dst;
		}
		src;
	}
}
