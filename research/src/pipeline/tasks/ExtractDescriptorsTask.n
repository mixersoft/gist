using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using Emgu.CV;
using Nemerle.Collections;
using Nemerle.Utility;
using PipelineMacro;
using Profiling;
using System.IO;
using System;

[ Record ]
class ExtractDescriptorsTask : ITask
{
	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		mutable mappings = [];
		foreach ((name, images, colors) in items.Join.[ImageCollectionItem, DominantColorItem]())
			mappings ::= TaskMapping(this, [ images, colors ], [ DescriptorItem(name) ]);
		mappings;
	}

	[ Profile(Recursive) ]
	private Compute
		( [InItem]  images : ImageCollectionItem
		, [InItem]  colors : DominantColorItem
		, [OutItem] result : DescriptorItem
		, imageSize          : int * int
		, colorWeight        : double
		) : void
	{
		def ExtractDescriptor =
			match (imageSize)
			{
			| (0, 0) =>
				fun (path)
				{
					using (image = Image.[Gray, byte](path))
						Gist.Algorithm.GetBwDescriptor(image, 4, 8, 8, 4);
				}
			| (w, h) =>
				fun (path)
				{
					using (image = Image.[Gray, byte](path))
					using (image = image.Resize(w, h, INTER.CV_INTER_LINEAR))
						Gist.Algorithm.GetBwDescriptor(image, 4, 8, 8, 4);
				}
			}

		def colors = colors.Colors;

		result.Descriptors = Hashtable();
		foreach (id in images.ImageIDs with i)
		{
			def path   = images.MakePath(id);
			def gist   = ExtractDescriptor(path);

			def descriptor = array(gist.Length + 3 * colors.GetLength(1));
			for (mutable j = 0; j != gist.Length; ++j)
				descriptor[j] = gist[j] :> double;
			for (mutable j = 0; j != colors.GetLength(1); ++j)
			{
				def (l, a, b) = colors[i, j].ToLab();
				descriptor[gist.Length + 3 * j + 0] = colorWeight * l;
				descriptor[gist.Length + 3 * j + 1] = colorWeight * a;
				descriptor[gist.Length + 3 * j + 2] = colorWeight * b;
			}

			result.Descriptors[id] = descriptor;
		}
	}
}
