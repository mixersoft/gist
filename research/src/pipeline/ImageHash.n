using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using Emgu.CV;
using System.Collections;
using System.Drawing;
using System.Security.Cryptography;
using System;

public module ImageHash
{
	public variant BlurMethod
	{
	| Median   { size : int }
	| Gaussian { factor : double }
	}

	public enum HashMethod
	{
	| Mean
	| Median
	| MD5
	}

	public GetHashCode
		( image           : Bitmap
		, hashMethod      : ImageHash.HashMethod
		, hashedImageSize : int
		, hashedImageBpp  : int
		) : int
	{
		match (hashMethod)
		{
		| Mean | Median => GetMeanHashCode(image, hashMethod)
		| MD5           => GetMD5HashCode(image, hashedImageSize, hashedImageBpp);
		}
	}

	public GetMeanHashCode(image : Bitmap, method : HashMethod) : int
	{
		def Resize(src : Bitmap) : Image.[Gray, float]
		{
			def (w, h) = if (src.Width > src.Height) (8, 4) else (4, 8);
			Image.[Gray, float](src).Resize(w, h, INTER.CV_INTER_LINEAR);
		}
		def GetHash(src : Image.[Gray, float])
		{
			def data : array[3, float] = src.Data;
			def (w, h) = (src.Width, src.Height);

			def pivot = GetPivot(data, method);

			mutable hash = 0u;
			for (mutable y = 0; y != h; ++y)
			for (mutable x = 0; x != w; ++x)
			{
				when (data[y, x, 0] > pivot)
					hash |= 1u << (y * w + x);
			}
			unchecked { hash :> int }
		}
		image |> Resize |> GetHash;
	}

	public GetMeanHashCodeLong(image : Bitmap, method : HashMethod) : ulong
	{
		def Resize(src : Bitmap) : Image.[Gray, float]
		{
			Image.[Gray, float](src).Resize(8, 8, INTER.CV_INTER_AREA);
			//Image.[Gray, byte](src)
			//	.Canny(Gray(128.0), Gray(128.0))
			//	.Convert.[Gray, float]()
			//	.Resize(8, 8, INTER.CV_INTER_AREA)
		}
		def GetHash(src : Image.[Gray, float])
		{
			def data : array[3, float] = src.Data;
			def (w, h) = (src.Width, src.Height);

			def pivot = GetPivot(data, method);

			mutable hash = 0ul;
			for (mutable y = 0; y != h; ++y)
			for (mutable x = 0; x != w; ++x)
			{
				when (data[y, x, 0] > pivot)
					hash |= (1:ulong) << (y * w + x);
			}
			hash;
		}
		image |> Resize |> GetHash;
	}

	public GetMD5HashCode(image : Bitmap, imageSize : int, bpp : int) : int
	{
		def Resize(src : Bitmap) : Image.[Gray, byte]
		{
			Image.[Gray, byte](src).Resize(imageSize, imageSize, INTER.CV_INTER_AREA)
		}
		def ToByteArray(src : Image.[Gray, byte]) : array[byte]
		{
			def data : array[3, byte] = src.Data;

			def (w, h) = (src.Width, src.Height);
			def bits = BitArray(bpp * w * h);
			mutable i = 0;
			for (mutable y = 0; y != h; ++y)
			for (mutable x = 0; x != w; ++x)
			{
				def value = data[y, x, 0] >> (8 - bpp);
				for (mutable bit = 0; bit != bpp; ++bit)
				{
					bits[i] = value & (1 << bit) != 0;
					++i;
				}
			}
			def bytes = array((bits.Count + 7) / 8); // divide rounding up
			bits.CopyTo(bytes, index = 0);
			bytes;
		}
		def Hash(data : array[byte]) : array[byte]
		{
			MD5.Create().ComputeHash(data)
		}
		def GetFirst32Bits(hash : array[byte]) : int
		{
			hash[0] | (hash[1] << 8) | (hash[2] << 16) | (hash[3] << 24)
		}
		image |> Resize |> ToByteArray |> Hash |> GetFirst32Bits;
	}

	private GetPivot(data : array[3, float], method : HashMethod) : float
	{
		def (w, h) = (data.GetLength(1), data.GetLength(0));
		def n = w * h;

		def GetMean()
		{
			mutable mean = 0.0f;
			for (mutable y = 0; y != h; ++y)
			for (mutable x = 0; x != w; ++x)
				mean += data[y, x, 0];
			mean / n;
		}
		def GetMedian()
		{
			def values = array(n);
			for (mutable y = 0; y != h; ++y)
			for (mutable x = 0; x != w; ++x)
				values[y * w + x] = data[y, x, 0];
			Array.Sort(values);
			if (n % 2 == 0)
				(values[n / 2 - 1] + values[n / 2]) / 2
			else
				values[n / 2]
		}

		match (method)
		{
		| MD5 | Mean => GetMean()
		| Median     => GetMedian()
		}
	}
}
