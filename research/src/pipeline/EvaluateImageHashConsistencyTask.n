using Nemerle.Collections;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Math;
using System.Windows;
using System.Windows.Media.Imaging;
using System.Windows.Media;
using System;

[ Record ]
class EvaluateImageHashConsistencyTask : ITask
{
	private parameters : Parameters;

	public Name : string { get { "EvaluateImageHashConsistencyTask" } }

	public MapItems(items : list[ITaskItem]) : list[TaskMapping]
	{
		def images = items
			.TypedFind(item : ImageCollectionItem => item.Path == "image-sample")
			.Value;
		def evaluation = ImageHashConsistencyEvaluationItem(@"eval\hash consistency.txt");
		[ TaskMapping
			( inputs  = [ images ]
			, outputs = [ evaluation ]
			, compute = () => Compute(images, evaluation)
			)
		]
	}

	private Compute
		( images     : ImageCollectionItem
		, evaluation : ImageHashConsistencyEvaluationItem
		) : void
	{
		def SubsampleHQ(src, dst, w, h)
		{
			ImageMagick.Convert(src, dst, $"-filter Lanczos -resize $(w)x$(h)> -quality 80");
		}
		def SubsampleLQ(src, dst, w, h)
		{
			ImageMagick.Convert(src, dst, $"-filter Lanczos -resize $(w)x$(h)> -quality 40");
		}
		def GetHashCode(path) : int
		{
			using (bmp = Bitmap(path))
				ImageHash.GetHashCode(bmp, parameters);
		}
		foreach (id in images.ImageIDs)
		{
			def sizes =
				[ /*(75, 75), */(120, 80), (144, 96), (222, 148)
				, (240, 161), (320, 214), (640, 428)
				];
			mutable hashes = [];
			foreach ((w, h) in sizes)
			{
				def path = images.MakePath(id);
				using (tmp = TempFile())
				{
					SubsampleHQ(path, tmp.Path, w, h);
					hashes ::= GetHashCode(tmp.Path);
					SubsampleLQ(path, tmp.Path, w, h);
					hashes ::= GetHashCode(tmp.Path);
				}
			}
			evaluation.Hashes ::= (id, hashes);
		}
	}
}
