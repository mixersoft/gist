using Nemerle.Collections;
using Nemerle.Utility;
using PipelineMacro;
using System.IO.File;
using System;

/// <summary>Meta-parameter source that loads from "parameters.txt".</summary>
public class Parameters
{
	//----------------
	// meta-parameters
	//----------------

	[ Parameter(LongName = "base data url") ]             public mutable BaseDataUrl            : string;
	[ Parameter(LongName = "clustering threshold") ]      public mutable ClusteringThreshold    : double;
	[ Parameter(LongName = "coarse event spacing") ]      public mutable CoarseEventSpacing     : double;
	[ Parameter(LongName = "color component weight") ]    public mutable ColorWeight            : double;
	[ Parameter(LongName = "day quota") ]                 public mutable DayQuota               : int;
	[ Parameter(LongName = "dominant color count") ]      public mutable DominantColorCount     : int;
	[ Parameter(LongName = "download image prefix") ]     public mutable DownloadImagePrefix    : string;
	[ Parameter(LongName = "duplicate threshold") ]       public mutable DuplicateThreshold     : int;
	[ Parameter(LongName = "fine event spacing") ]        public mutable FineEventSpacing       : double;
	[ Parameter(LongName = "hash method") ]               public mutable HashMethod             : ImageHash.HashMethod;
	[ Parameter(LongName = "hashed image blur") ]         public mutable HashedImageBlur        : ImageHash.BlurMethod;
	[ Parameter(LongName = "hashed image bpp") ]          public mutable HashedImageBpp         : int;
	[ Parameter(LongName = "hashed image size") ]         public mutable HashedImageSize        : int;
	[ Parameter(LongName = "image sample size") ]         public mutable ImageSampleSize        : int;
	[ Parameter(LongName = "image size") ]                public mutable ImageSize              : int * int;
	[ Parameter(LongName = "kde window") ]                public mutable KdeWindow              : double;
	[ Parameter(LongName = "mean shift iteration count") ]public mutable MSIterationCount       : int;
	[ Parameter(LongName = "mean shift kernel") ]         public mutable MSKernel               : MeanShiftKernel;
	[ Parameter(LongName = "simulated timeline count") ]  public mutable SimulatedTimelineCount : int;
	[ Parameter(LongName = "thumbnail height") ]          public mutable ThumbHeight            : int;

	//-----------------------
	// implementation methods
	//-----------------------

	private SplitParameterLine(line : string) : option[string * string]
	{
		match (line.IndexOf('='))
		{
		| -1 => None()
		| i  =>
			def name  = line.Substring(0, i).Trim();
			def value = line.Substring(i + 1).Trim();
			Some(name, value);
		}
	}

	//--------
	// parsing
	//--------

	private Parse(text : string, value : out double) : void
	{
		value = double.Parse(text);
	}

	private Parse(text : string, value : out int) : void
	{
		value = int.Parse(text);
	}

	private Parse(text : string, value : out ImageHash.BlurMethod) : void
	{
		value = match (text.SplitToList(' '))
		{
		| ["median", size] => ImageHash.BlurMethod.Median(int.Parse(size))
		| ["gaussian", σ]  => ImageHash.BlurMethod.Gaussian(double.Parse(σ))
		| _ => throw Exception($"Invalid blur format: '$text'.")
		}
	}

	private Parse(text : string, value : out ImageHash.HashMethod) : void
	{
		value = match (text)
		{
		| "md5"  => ImageHash.HashMethod.MD5
		| "mean" => ImageHash.HashMethod.Mean
		| _ => throw Exception($"Invalid hash method: '$text'.")
		}
	}

	private Parse(text : string, value : out MeanShiftKernel) : void
	{
		value = match (text)
		{
		| "epanechnikov" => MeanShiftKernel.Epanechnikov
		| "gaussian"     => MeanShiftKernel.Gaussian
		| _ => throw Exception($"Invalid mean shift kernel: '$text'.")
		}
	}

	private Parse(text : string, value : out int * int) : void
	{
		value = match (text.SplitToList(' '))
		{
		| [w, h] => (int.Parse(w), int.Parse(h))
		| _ => throw Exception($"Incorrect size format: '$text'.")
		}
	}

	private Parse(text : string, value : out string) : void
	{
		value = text;
	}
}
